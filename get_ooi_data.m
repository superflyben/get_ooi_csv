%Script to read OOI data from files catalouged in webpage generated by OOI
%data request. Start with download link in e-mail, end with Matlab variable
%containing data

%% Global variables
t0 = cputime;
c0 = now;

%Choose to get data as strings (1) or as numbers (2)
%NOTE: Option 1 is faster, but results in very large data files
%--> Consider using memory mapping for this option so prevent maxing out
%    computer RAM
choice = 2;
%% Get the XML catalog 
%Enter download link contained in e-mail received from
%noreply@oceanobservatories.org

%For Resistivity Probe
webpage = ['http://opendap.oceanobservatories.org:8090/thredds/catalog/'...
           'ooi/ben-larson-noaa/20160927T084046-RS03INT1-MJ03C-10-'...
           'TRHPHA301-streamed-trhph_sample/catalog.html'];

%For H2-H2S-pH sensor (not yet tested)
% webpage = ['http://opendap.oceanobservatories.org:8090/thredds/catalog/'...
%            'ooi/ben-larson-noaa/20160928T071241-RS03INT1-MJ03C-09-'...
%            'THSPHA301-streamed-thsph_sample/catalog.html'];

%Change .html extenstion to .xml for easier reading??
%NOTE: could just do this manually, but hope to eventually automate the url
%      request step that is currently done by e-mail
webpage = strrep(webpage,'.html','.xml');

%Read xml content from url into Matlabc variable.
c1 = now;
raw = urlread(webpage);

%Show Progress
fprintf(['Data catalog retrieved from server \n'...
         'Computer time: %f seconds \n',...
         'Clock time: %f seconds \n\n'],...
         (cputime - t0),(now - c1)*24*60*60);

%Split content with end of line as delimiters
%NOTE: 'strsplit' seems to work with either '\n' or '\r' as delimiters, but
%      NOT both. Used 'double' command to verify there are 2 characters at
%      the end of each line, with ascii codes 13 (carriage return), and
%      10 (line feed).
webLines = strsplit(raw,'\n');

%Get line numbers for all lines containg a dataset tag but NOT the
%corresponding /dataset end tag
dataLineNum = setdiff(getlines(webLines,'dataset'),...
                    getlines(webLines,'/dataset'));

%% Scrape the catalog for path and file names
%Initiate storage array for urls
address = {};

%Loop through all lines with a dataset and retrieve the urlpath
%NOTE: dataLines must be in 1xN form
for lineNum = dataLineNum'
    %Get the url path from the xml line
    [urlToken,substr] = regexp(webLines{lineNum},...
                               'urlPath="(.*\.csv)">','tokens','match');
                    
	%Extract address from the token (if not empty), add to a cell array
    if ~isempty(urlToken)
        address{end+1,1} = [urlToken{1}{1}];
    end
end

%% Read and concatenate data

%Use link from scraping to download the .csv file.
%NOTE: Requires an additional prefix to the url:
%--> Where does this link come from?
prefix = 'http://opendap.oceanobservatories.org:8090/thredds/fileServer/';

%Initiate a line counter 
numLines = 0;
for i=1:length(address)
    %Read the data file (returned as a single string)
    c2 = now;
    csvData = urlread([prefix address{i}]);
    
    fprintf(['Data file retrieved from server \n'...
             'Computer time: %f seconds \n'...
             'Clock time: %f seconds \n\n'],...
             (cputime - t0),(now - c2)*24*60*60);
    
    %Show progress
    fprintf(['Data retrieved from server \n'...
             'Computer time: %f seconds \n\n'],(cputime - t0));
    
    %Split string first by newline (\n),
    strLines = strsplit(csvData,'\n');
    %Get rid of empty lines
    strLines = strLines(~cellfun(@isempty, strLines));
    
    %Show progress
    fprintf(['Data split by line \n'...
             'Computer time: %f seconds \n\n'],(cputime - t0));
    
    %Get headers from first file
    %Returned as columns in a single row
    if i==1;
        headers = strsplit(strLines{1},',');
    end
         
    %Split data in each row into string elements
    %NOTE: textscan returns output as rows
    %NOTE: strsplit (which is much MUCH slower than textscan) returns
    %      output as columns  
    dataLines = cellfun(@(x) textscan(x,'%s','Delimiter',','),...
                        strLines(2:end));
    %Show progress
    fprintf(['Each line split into elements \n'...
             'Computer time: %f seconds \n\n'],(cputime - t0));
         
    %if first file, initiate allData storage matrix
    if i==1
        %Pre-allocate large number of rows, and exact number of columns*
        %NOTE: will shrink rows later
        numRows = 3.5e6;
        if choice==1
            %For text
            allData = cell(numRows,length(headers));
        elseif choice==2
            %For numbers
            allData = zeros(numRows,length(headers));
        end
    end
    
    %Loop over lines for current files and append line elements
    for j=1:length(dataLines)
        %Get a single row of data elements, and add to storage array
        if choice==1;
            %Keep as text
            data = dataLines{j}';
            %Add line of data
            allData(numLines+j,:) = data;
            
        elseif choice==2
            %Convert strings to number before appending to storage array
            %non-numbers convert to NaN
            data = cellfun(@(x) str2double(x), dataLines{j}');
            %Add line of data
            allData(numLines+j,:) = data;
        end
        
        %Counter for progress through lines in file
        if mod(j,5000)==0
            fprintf(['Line Number: %d of %d \n'...
                     'Computer time: %f seconds \n\n'],...
                     j,length(strLines),(cputime - t0));
        end
    end
    
    %Set cumulative counter to end of current file
    numLines = numLines + j;
    
    %Counter for progress through files in catalog
    fprintf(['Finished Processing File %d of %d \n'...
             'Computer time: %f seconds \n\n\n\n'],...
             i,length(address),(cputime - t0));
end

%Trim storage array to current number of lines
allData(numLines+1:end,:) = [];

%% Show some data
dataHead = array2table(allData(1:10,:),'VariableNames',headers)

%Show final stats
fprintf(['All data processed \n'...
         'Computer time: %f seconds \n'...
         'Clock time: %f seconds \n\n'],...
         (cputime - t0),(now - c0)*24*60*60);

%*Speed advantage realized by pre-allocating space based on cpu time
% required to process 5000 row increments. The bigger the array, the bigger
% the penalty
%
%CPU time (s) required to process subsequent 5000 row blocks
%w/o pre-allocation     w/ pre-allocation
%       17.5033                11.0137
%       21.4969                11.1696
%       25.8182                11.1385
%       29.9054                11.2165
%       33.9146                11.0760
%       38.0018                11.1229
%       42.2763                11.0917


